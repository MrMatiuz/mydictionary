НУЖНО ДОРАБОТАТЬ:
1. Запись логов. Сейчас добавляется пустая строка, но это неправильно. Не понял, как перенести запись на новую строку при 
добавлении к существующему файлу. Он первую строку всегда прибавляет к последней входного файла
2. Скорреткировать функию ранжирования, потому что слишком часто он зацикливается на одних и тех же словах
3. Добавить параметр, который в самом начале дает рандомные слова, чтоб клиент смог хотя бы раз увидеть незнакомы слова

Ранжирование слов:
1. Перед началом работы надо прорандировать N слов, которые будут выпадать слиенту. 
2. Если клиент дошел до N-ого слова, тогда надо поменять метрики слов и запустить заново ранжирование,
    где соберется новый пул из N слов.
3. Включать это ранжирование стоит, когда мы клиент пройдется по всем M словам, 
    иначе мы всегда будем давать новые слова, что приведет к тому, что при большом словаре не будет повторений.
    Думаю зафиксровать на M=N. Но при большом N Получаем такой же эффект -> N тоже должен быть приемлемой длины.

Проставление рагнов:
1. Использовать accuracy как метрику вероятности отнесения слова к известному клиенту.
2. Так же брать среднее время на вспоминание. Если слово в пределаю 1 сигмы известных слов, тогда все хорошо.
    Тогда метрика будет расти быстрее, при отдалении от среднее в сторону 0.
    Тогда это слово можно выкидывать реже.
    Слово считаем известным, если его accuracy > 80%
    Введем значение этих сигм, чтоб постоянно их не пересчитывать и запишем их в отдельный файл.
3. Probability = 0.5 * accuracy + 0.5 * (metric)
4. Metric состоит из двух функций: парабола (можно взять и логарифм) и прямой:
def metric(x, x_last, x_critical):
    if x >= 0:
        if x >= x_last:
            return 0
        else:
            if x < x_critical:
                return -1 / (x_last * x_critical) * x**2 + 1
            else:
                return -x / x_last + 1
    else:
        return 1
